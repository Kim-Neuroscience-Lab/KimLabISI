#!/usr/bin/env python3
"""
Dead Code Analysis Script using Vulture

This script runs vulture on the codebase to identify potentially dead/unused code.
Vulture finds unused functions, variables, classes, imports, and more.
"""

import sys
import subprocess
import argparse
from pathlib import Path
import tempfile


def create_whitelist():
    """Create a whitelist for common false positives"""
    whitelist_content = """
# Common false positives whitelist for ISI Macroscope Control System

# Pydantic model fields that appear unused but are used by the framework
_.model_config
_.model_dump
_.model_validate
_.model_fields
_.model_extra

# Abstract interface methods that must be implemented
_.initialize
_.cleanup
_.get_status
_.get_capabilities

# Async context managers
_.__aenter__
_.__aexit__

# Protocol/ABC methods that appear unused
_.process_data
_.upload_data
_.download_data
_.execute_kernel

# CLI entry points
main
run
cli

# Test fixtures and setup methods
setup_method
teardown_method
setUp
tearDown

# Common magic methods
_.__str__
_.__repr__
_.__eq__
_.__hash__

# Common properties that might appear unused
_.current_state
_.development_mode
_.platform_info

# Enum values (might appear unused but are accessed dynamically)
WorkflowState.*
HardwareRequirement.*
PlatformType.*

# Exception classes (used in raise statements)
*Error
*Exception

# Logger instances (used in string formatting)
logger

# Config and settings classes
*Config
*Settings

# Type hints and annotations
typing.*
Optional
Dict
List
Any
"""

    # Write to temporary file
    with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
        f.write(whitelist_content)
        return f.name


def run_vulture_analysis(target_dir: Path, confidence: int = 80, whitelist_file: str = None):
    """Run vulture analysis on the target directory"""

    cmd = [
        'python', '-m', 'vulture'
    ]

    # Add paths first
    if whitelist_file:
        cmd.extend([str(target_dir), whitelist_file])
    else:
        cmd.append(str(target_dir))

    # Add options
    cmd.extend([
        '--min-confidence', str(confidence),
        '--sort-by-size'
    ])

    print(f"🔍 Running Vulture dead code analysis...")
    print(f"📁 Target: {target_dir}")
    print(f"🎯 Confidence threshold: {confidence}%")
    print(f"📝 Command: {' '.join(cmd)}")
    print("=" * 60)

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, cwd=target_dir.parent)

        if result.stdout:
            print("📊 DEAD CODE ANALYSIS RESULTS:")
            print("=" * 60)
            print(result.stdout)

        if result.stderr:
            print("\n⚠️  WARNINGS/ERRORS:")
            print("=" * 30)
            print(result.stderr)

        return result.returncode == 0, result.stdout, result.stderr

    except Exception as e:
        print(f"❌ Error running vulture: {e}")
        return False, "", str(e)


def parse_vulture_output(output: str):
    """Parse vulture output and categorize findings"""

    categories = {
        'unused_imports': [],
        'unused_functions': [],
        'unused_classes': [],
        'unused_variables': [],
        'unused_attributes': [],
        'other': []
    }

    lines = output.strip().split('\n')
    for line in lines:
        if not line.strip():
            continue

        line = line.strip()

        if 'unused import' in line.lower():
            categories['unused_imports'].append(line)
        elif 'unused function' in line.lower():
            categories['unused_functions'].append(line)
        elif 'unused class' in line.lower():
            categories['unused_classes'].append(line)
        elif 'unused variable' in line.lower():
            categories['unused_variables'].append(line)
        elif 'unused attribute' in line.lower():
            categories['unused_attributes'].append(line)
        else:
            categories['other'].append(line)

    return categories


def generate_report(categories: dict, output_file: Path = None):
    """Generate a comprehensive report of dead code findings"""

    report_lines = []
    report_lines.append("# Dead Code Analysis Report")
    report_lines.append(f"Generated by Vulture\n")

    total_issues = sum(len(items) for items in categories.values())
    report_lines.append(f"**Total Issues Found: {total_issues}**\n")

    for category, items in categories.items():
        if not items:
            continue

        category_name = category.replace('_', ' ').title()
        report_lines.append(f"## {category_name} ({len(items)} items)")
        report_lines.append("")

        for item in items:
            # Try to extract file and line info
            if ':' in item:
                parts = item.split(':', 2)
                if len(parts) >= 3:
                    file_path, line_num, description = parts[0], parts[1], parts[2].strip()
                    report_lines.append(f"- `{file_path}:{line_num}` - {description}")
                else:
                    report_lines.append(f"- {item}")
            else:
                report_lines.append(f"- {item}")

        report_lines.append("")

    # Priority recommendations
    report_lines.append("## Recommendations")
    report_lines.append("")
    report_lines.append("### High Priority")
    if categories['unused_imports']:
        report_lines.append("- **Remove unused imports** - These are safe to remove and improve code clarity")
    if categories['unused_variables']:
        report_lines.append("- **Review unused variables** - May indicate incomplete implementations")

    report_lines.append("")
    report_lines.append("### Medium Priority")
    if categories['unused_functions']:
        report_lines.append("- **Review unused functions** - Verify these aren't part of public APIs")
    if categories['unused_classes']:
        report_lines.append("- **Review unused classes** - Check if these are intended for future use")

    report_lines.append("")
    report_lines.append("### Notes")
    report_lines.append("- Some findings may be false positives (framework methods, abstract implementations)")
    report_lines.append("- Always verify before removing code - it might be used dynamically")
    report_lines.append("- Consider adding items to whitelist if they're intentionally unused")

    report_content = '\n'.join(report_lines)

    if output_file:
        with open(output_file, 'w') as f:
            f.write(report_content)
        print(f"📄 Report saved to: {output_file}")

    return report_content


def main():
    parser = argparse.ArgumentParser(description="Run dead code analysis using Vulture")
    parser.add_argument(
        '--target',
        type=Path,
        default=Path.cwd() / 'src',
        help='Target directory to analyze (default: ./src)'
    )
    parser.add_argument(
        '--confidence',
        type=int,
        default=80,
        help='Minimum confidence threshold (0-100, default: 80)'
    )
    parser.add_argument(
        '--no-whitelist',
        action='store_true',
        help='Skip using the default whitelist'
    )
    parser.add_argument(
        '--output',
        type=Path,
        help='Output report file (markdown format)'
    )
    parser.add_argument(
        '--whitelist',
        type=Path,
        help='Custom whitelist file'
    )

    args = parser.parse_args()

    if not args.target.exists():
        print(f"❌ Target directory does not exist: {args.target}")
        sys.exit(1)

    # Determine whitelist file
    whitelist_file = None
    if not args.no_whitelist:
        if args.whitelist and args.whitelist.exists():
            whitelist_file = str(args.whitelist)
        else:
            whitelist_file = create_whitelist()

    try:
        # Run analysis
        success, output, error = run_vulture_analysis(
            args.target,
            args.confidence,
            whitelist_file
        )

        if not success and error and not output:
            print(f"❌ Analysis failed: {error}")
            sys.exit(1)
        elif error and not success:
            print(f"⚠️  Analysis completed with warnings (non-fatal)")

        # Parse and report results
        if output:
            categories = parse_vulture_output(output)
            report = generate_report(categories, args.output)

            # Print summary
            total_issues = sum(len(items) for items in categories.values())
            print(f"\n📊 SUMMARY:")
            print(f"Total dead code issues found: {total_issues}")

            for category, items in categories.items():
                if items:
                    category_name = category.replace('_', ' ').title()
                    print(f"- {category_name}: {len(items)}")

            if total_issues == 0:
                print("🎉 No dead code found!")
            else:
                print(f"\n💡 Consider reviewing and removing unused code to improve maintainability.")

        else:
            print("🎉 No dead code found!")

    finally:
        # Clean up temporary whitelist file
        if whitelist_file and 'tmp' in whitelist_file:
            try:
                Path(whitelist_file).unlink()
            except:
                pass


if __name__ == "__main__":
    main()